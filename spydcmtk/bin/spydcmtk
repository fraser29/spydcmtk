#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
spydcmtk.py
Adapted and generalised from KISPI ZfMRF Dicom ToolKit March 2023

@author: Fraser Callaghan

Dicom organisation and anonymising script.
"""


from context import spydcm
import os
import argparse

from spydcm import dcmTK
from spydcm import dcmUtils
    

### ====================================================================================================================
##          INSPECTION / VERIFICATION
### ====================================================================================================================
def quickInspect(dStudies, FULL):
    frmtStr = dStudies.getSummaryString(FULL)
    print(frmtStr)

def checkArgs(args):
    allActionArgs = [args.nii, 
                args.vti, 
                args.quickInspect, 
                args.quickInspectFull, 
                args.outputFolder is not None]
    return any(allActionArgs)

### ====================================================================================================================
##          RUN
### ====================================================================================================================
def runActions(args):

    ####
    if args.dcmdump:
        ds = dcmUtils.returnFirstDicomFound(args.inputPath, FILE_NAME_ONLY=False)
        print(ds)
    else:
        # check arguments to avoid reading all dicoms and then doing nothing...
        if not checkArgs(args):
            ap.exit(0, f'No action given. Exiting SPYDCMTK without action\n')
        try:
            onlyOverview = args.quickInspect or args.quickInspectFull
            ListDicomStudies = dcmTK.ListOfDicomStudies.setFromInput(args.inputPath, HIDE_PROGRESSBAR=args.QUIET, FORCE_READ=args.FORCE, OVERVIEW=onlyOverview) 
        except IOError as e:
            ap.exit(1, f'Error reading {args.inputPath}.\n    {e}')
        # Let IOERROR play out here is not correct input
        ##
        if args.quickInspect or args.quickInspectFull:
                print(ListDicomStudies.getSummaryString(args.quickInspectFull))
        else:
            if args.outputFolder is None:
                print(f'WARNING: outputFolder not given - setting to inputFolder')
                args.outputFolder = os.path.split(args.inputPath)[0]
            if args.nii:
                for iDS in ListDicomStudies:
                    for iSeries in iDS:
                        iSeries.writeToNII(outputPath=args.outputFolder, outputNaming=['PatientName', 'SeriesNumber', 'SeriesDescription'])
            elif args.vti:
                for iDS in ListDicomStudies:
                    for iSeries in iDS:
                        iSeries.writeToVTI(outputPath=args.outputFolder, outputNaming=['PatientName', 'SeriesNumber', 'SeriesDescription'])
            elif args.outputFolder is not None:
                outDirList = ListDicomStudies.writeToOrganisedFileStructure(args.outputFolder, anonName=args.anonName)
                allDirsPresent = all([os.path.isdir(i) for i in outDirList])
                res = 0 if allDirsPresent else 1
                ap.exit(res, f'Transfer and sort from {args.inputPath} to {args.outputFolder} COMPLETE\n')
        ##

### ====================================================================================================================
### ====================================================================================================================
# S T A R T
#
if __name__ == '__main__':

    # --------------------------------------------------------------------------
    #  ARGUMENT PARSING
    # --------------------------------------------------------------------------
    ap = argparse.ArgumentParser(description='Simple Python Dicom Toolkit - spydcmtk')

    ap.add_argument('-i', dest='inputPath', help='Path to find dicoms (file or directory or tar or tar.gz or zip)', type=str, required=True)
    ap.add_argument('-o', dest='outputFolder', help='Path for output - if set then will organise dicoms into this folder', type=str, default=None)

    ap.add_argument('-a', dest='anonName',
        help='anonymous name [optional - if not given, then not anoymised]', type=str, default=None)
    ap.add_argument('-quickInspect', dest='quickInspect',
        help='Will output a summary of dicoms to the terminal', action='store_true')
    ap.add_argument('-quickInspectFull', dest='quickInspectFull',
        help='Will output a full summary of dicoms to the terminal', action='store_true')
    ap.add_argument('-dcmdump', dest='dcmdump',
        help='Will output a dump of all dicom tags to the terminal (from first found dicom)', action='store_true')
    ap.add_argument('-nii', dest='nii',
        help='Will convert each series to nii.gz. Naming: {PName}_{SE#}_{SEDesc}.nii.gz', action='store_true')
    ap.add_argument('-vti', dest='vti',
        help='Will convert each series to vti. Naming: {PName}_{SE#}_{SEDesc}.vti', action='store_true')
    # -- program behaviour guidence -- #
    ap.add_argument('-FORCE', dest='FORCE', help='force reading even if not standard dicom (needed if dicom files missing header meta)',
                            action='store_true')
    ap.add_argument('-QUIET', dest='QUIET', help='Suppress progress bars and information output to terminal',
                            action='store_true')
    ##

    arguments = ap.parse_args()
    if arguments.inputPath is not None:
        arguments.inputPath = os.path.abspath(arguments.inputPath)
        if not arguments.QUIET:
            print(f'Running SPYDCMTK with input {arguments.inputPath}')
    ## -------------

    runActions(arguments)
